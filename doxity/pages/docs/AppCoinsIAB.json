{"author":"App Store Foundation","title":"AppCoinsIAB Interface","fileName":"/contracts/AppCoinsIAB.sol","name":"AppCoinsIAB","abi":[{"constant":true,"inputs":[{"name":"_packageName","type":"string"},{"name":"_sku","type":"string"},{"name":"_amount","type":"uint256"},{"name":"_addr_appc","type":"address"},{"name":"_dev","type":"address"},{"name":"_appstore","type":"address"},{"name":"_oem","type":"address"},{"name":"_countryCode","type":"bytes2"}],"name":"buy","outputs":[{"name":"result","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_numerator","type":"uint256"},{"name":"_denominator","type":"uint256"}],"name":"division","outputs":[{"name":"result","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"}],"bin":"","opcodes":"","source":"pragma solidity ^0.4.19;\n\ncontract AppCoins {\n    mapping (address => mapping (address => uint256)) public allowance;\n    function balanceOf (address _owner) public view returns (uint256);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\n}\n/**\n@title AppCoinsIAB Interface\n@author App Store Foundation\n@dev Base interface to implement In-app-billing functions.\n*/\ncontract AppCoinsIABInterface {\n    /**\n    @notice Returns the division of two numbers\n    @dev\n        Function used for division operations inside the smartcontract\n    @param _numerator Numerator part of the division\n    @param _denominator Denominator part of the division\n    @return { \"result\" : \"Result of the division\"}\n    */\n    function division(uint _numerator, uint _denominator) public view returns (uint result);\n    /**\n    @notice Function to register a in-app-billing operation\n    @dev\n        Registers a in-app-billing operation with the needed information and transfers the correct \n        amount from the user to the developer and remaining parties.\n    @param _packageName Package name of the application from which the in-app-billing was generated\n    @param _sku Item id for the item bought inside the specified application\n    @param _amount Value (in wei) of AppCoins to be paid for the item\n    @param _addr_appc Address of the AppCoins (ERC-20) contract to be used\n    @param _dev Address of the application's developer\n    @param _appstore Address of the appstore to receive part of the share\n    @param _oem Address of the OEM to receive part of the share\n    @param _countryCode Country code of the country from which the transaction was issued\n    @return {\"result\" : \"True if the transaction was successfull\"}\n    */\n    function buy(\n        string _packageName, string _sku, uint256 _amount, address _addr_appc, address _dev, \n        address _appstore, address _oem, bytes2 _countryCode) \n        public view \n        returns (bool result);\n}\n\ncontract AppCoinsIAB is AppCoinsIABInterface {\n\n    uint public dev_share = 85;\n    uint public appstore_share = 10;\n    uint public oem_share = 5;\n\n    mapping (address => bool) allowedAddresses;\n    address owner;\n\n    modifier onlyAllowedAddress(string _funcName) {\n        if(!allowedAddresses[msg.sender]){\n            emit Error(_funcName, \"Operation can only be performed by allowed Addresses\");\n            return;\n        }\n        _;\n    }\n\n    modifier onlyOwner(string _funcName) {\n        if(owner != msg.sender){\n            emit Error(_funcName, \"Operation can only be performed by contract owner\");\n            return;\n        }\n        _;\n    }\n\n\n    event Buy(string packageName, string _sku, uint _amount, address _from, address _dev, address _appstore, address _oem, bytes2 countryCode);\n    event Error(string func, string message);\n    event OffChainBuy(address _wallet, bytes32 _rootHash);\n    \n    /**\n    @notice Constructor function\n    @dev\n        Initializes contract and registers the contract owner.\n    */\n    function AppCoinsIAB() public {\n        owner = msg.sender;\n    }\n\n    /**\n    @notice Adds address to allowed list\n    @dev\n        Adds a new address to the allowed list to perform certain operations using the IAB contract.\n    @param _account Address to add to the allowed adresses list\n    */\n    function addAllowedAddress(address _account) public onlyOwner(\"addAllowedAddress\"){\n        allowedAddresses[_account] = true;\n    }\n\n\n    /**\n    @notice Removes address to allowed list\n    @dev\n        Removes an address from the allowed list, denying certain operations using the IAB contract.\n    @param _account Address to remove from the allowed adresses list\n    */\n    function removeAllowedAddress(address _account) public onlyOwner(\"removeAllowedAddress\") {\n        allowedAddresses[_account] = false;\n    }\n\n    /**\n    @notice Emmits an event informing offchain transactions for in-app-billing\n    @dev\n        For each wallet passed as argument, the specified roothash is emited in a OffChainBuy event.\n        This function is only avaliable to a set of allowed adresses. This function will emit an \n        Error event when the list of wallets passed as argument does not have the same length \n        as the list of roothashs given.\n\n    @param _walletList List of wallets for which a OffChainBuy event will be issued\n    @param _rootHashList List of roothashs for given transactions\n    */\n    function informOffChainBuy(address[] _walletList, bytes32[] _rootHashList) public onlyAllowedAddress(\"informOffChainTransaction\") {\n        if(_walletList.length != _rootHashList.length){\n            emit Error(\"informOffChainTransaction\", \"Wallet list and Roothash list must have the same lengths\");\n            return;\n        }\n        for(uint i = 0; i < _walletList.length; i++){\n            emit OffChainBuy(_walletList[i],_rootHashList[i]);\n        }\n    }\n\n     /**\n    @notice Returns the division of two numbers\n    @dev\n        Function used for division operations inside the smartcontract\n    @param _numerator Numerator part of the division\n    @param _denominator Denominator part of the division\n    @return { \"result\" : \"Result of the division\"}\n    */\n    function division(uint _numerator, uint _denominator) public view returns (uint result) {\n        uint quotient = _numerator / _denominator;\n        return quotient;\n    }\n\n\n    function buy(string _packageName, string _sku, uint256 _amount, address _addr_appc, address _dev, address _appstore, address _oem, bytes2 _countryCode) public view returns (bool) {\n        require(_addr_appc != 0x0);\n        require(_dev != 0x0);\n        require(_appstore != 0x0);\n        require(_oem != 0x0);\n\n        AppCoins appc = AppCoins(_addr_appc);\n        uint256 aux = appc.allowance(msg.sender, address(this));\n        if(aux < _amount){\n            emit Error(\"buy\",\"Not enough allowance\");\n            return false;\n        }\n\n        uint[] memory amounts = new uint[](3);\n        amounts[0] = division(_amount * dev_share, 100);\n        amounts[1] = division(_amount * appstore_share, 100);\n        amounts[2] = division(_amount * oem_share, 100);\n\n        appc.transferFrom(msg.sender, _dev, amounts[0]);\n        appc.transferFrom(msg.sender, _appstore, amounts[1]);\n        appc.transferFrom(msg.sender, _oem, amounts[2]);\n\n        emit Buy(_packageName, _sku, _amount, msg.sender, _dev, _appstore, _oem, _countryCode);\n\n        return true;\n    }\n}\n","abiDocs":[{"constant":true,"inputs":[{"name":"_packageName","type":"string","description":"Package name of the application from which the in-app-billing was generated"},{"name":"_sku","type":"string","description":"Item id for the item bought inside the specified application"},{"name":"_amount","type":"uint256","description":"Value (in wei) of AppCoins to be paid for the item"},{"name":"_addr_appc","type":"address","description":"Address of the AppCoins (ERC-20) contract to be used"},{"name":"_dev","type":"address","description":"Address of the application's developer"},{"name":"_appstore","type":"address","description":"Address of the appstore to receive part of the share"},{"name":"_oem","type":"address","description":"Address of the OEM to receive part of the share"},{"name":"_countryCode","type":"bytes2","description":"Country code of the country from which the transaction was issued"}],"name":"buy","outputs":[{"name":"result","type":"bool","description":"True if the transaction was successfull"}],"payable":false,"stateMutability":"view","type":"function","details":"Registers a in-app-billing operation with the needed information and transfers the correct  amount from the user to the developer and remaining parties.","return":"{\"result\" : \"True if the transaction was successfull\"}","notice":"Function to register a in-app-billing operation","signature":"buy(string,string,uint256,address,address,address,address,bytes2)","signatureHash":"b7a2e1f2"},{"constant":true,"inputs":[{"name":"_numerator","type":"uint256","description":"Numerator part of the division"},{"name":"_denominator","type":"uint256","description":"Denominator part of the division"}],"name":"division","outputs":[{"name":"result","type":"uint256","description":"Result of the division"}],"payable":false,"stateMutability":"view","type":"function","details":"Function used for division operations inside the smartcontract","return":"{ \"result\" : \"Result of the division\"}","notice":"Returns the division of two numbers","signature":"division(uint256,uint256)","signatureHash":"e0068052"}]}
