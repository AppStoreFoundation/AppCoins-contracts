{"fileName":"/contracts/AppCoinsBClass.sol","name":"AppCoinsBClass","abi":[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"}],"bin":"","opcodes":"","source":"// AppCoins class B token contract\n\npragma solidity ^0.4.21;\n\ncontract ERC20Interface {\n    function name() public view returns(bytes32);\n    function symbol() public view returns(bytes32);\n    function balanceOf (address _owner) public view returns(uint256 balance);\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n}\n\ncontract AppCoins {\n    uint256 public totalSupply;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    function balanceOf (address _owner) public view returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint);\n}\n\ncontract AppCoinsIAB {\n    function division(uint numerator, uint denominator) public view returns (uint);\n    function buy(uint _amount, string _sku, address _addr_appc, address _dev, address _appstore, address _oem) public view returns (bool);\n}\n\n\ncontract AppCoinsBClass is ERC20Interface {\n\n    address public owner;\n    bytes32 private tokenName;\n    bytes32 private tokenSymbol;\n    uint8 public decimals = 18;\n\t// 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n\t// This creates an array with all balances\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    AppCoins appc;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    // This notifies clients about the amount created as class B tokens\n    event Create(uint256 value, uint256 newTotalSupply);\n\n    function AppCoinsBClass (address addrAppc)  public {\n        owner = msg.sender;\n        tokenName = \"AppCoinsB\";\n        tokenSymbol = \"APPCB\";\n        totalSupply = 0; // Initialy there are 0 class B tokens and the supply is updated as tokens are converted\n        appc = AppCoins(addrAppc);\n    }   \n\n    function name () public view returns(bytes32) {\n        return tokenName;\n    }\n    \n    function symbol () public view returns(bytes32) {\n        return tokenSymbol;\n    }\n\n    function balanceOf (address _owner) public view returns(uint256 balance) {\n        return balances[_owner];\n    }\n\n    /** \n     *  Convert class A tokens to class B tokens and transfers \n     *  them to the defined address\n     *  \n     *  @param to The address of the receiver \n     *  @param _value the amount to convert \n    */\n    function convertAndTransfer(address to,uint _value) external {\n        //Transfer A class AppCoins to B class AppCoins contract\n        require(appc.allowance(msg.sender, address(this)) >= _value);\n        appc.transferFrom(msg.sender, address(this), _value);\n\n        createToken(to,_value);\n    }\n    /**\n     *  Convert class B tokens to class A tokens \n     *  can only be called from IAB contract\n     *\n     *  @param to The address of the receiver\n     *  @param _value the amount to transfer\n     */\n\n    function revertAndTransfer(address to, uint _value) external returns (uint){\n        //revert can only be done by IAB contract\n        // FIXME require (msg.sender == address(AppCoinsIAB));\n        // check that AppCoinsB contract has balance for the transaction\n        require (appc.balanceOf(address(this)) >= _value);\n        \n        require (balances[to] >= _value);\n        \n        // destroy class B tokens\n        burn(_value);\n        \n        // transfer class A tokens from AppCoinsBClass to receiver \n        appc.transfer(to,_value);\n\n        emit Transfer(to,address(this),_value); \n    }\n\t\n    /**\n     *  Create token\n     *\n     *  Creates '_value' new tokens, updates total supply \n     *  and transfers tokens to 'to' address\n     *\n     *  @param to The address of the receiver\n     *  @param _value the amount of class B token to be created\n     */\n    function createToken(address to, uint256 _value) internal {\n        // Update B class AppCoins supply\n        totalSupply += _value;\n        // Update recipient balance\n        balances[to] += _value;\n\n        emit Create(_value,totalSupply);\n        emit Transfer(address(this),to,_value); \n    }\n\n\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balances[_from] >= _value);\n        // Check for overflows\n        require(balances[_to] + _value > balances[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balances[_from] + balances[_to];\n        // Subtract from the sender\n        balances[_from] -= _value;\n        // Add the same to the recipient\n        balances[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balances[_from] + balances[_to] == previousBalances);    \n    }\n\n    // /**\n    //  * Transfer tokens\n    //  *\n    //  * Send `_amount` tokens to `_to` from your account\n    //  *\n    //  * @param _to The address of the recipient\n    //  * @param _amount the amount to send\n    //  */\n    // function transfer(address _to, uint256 _amount) public {\n    //     _transfer(msg.sender, _to, _amount);\n    // }\n    function transfer (address _to, uint256 _amount) public returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\n            \n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            emit Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (uint) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return allowance[_from][msg.sender];\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\t/**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     * Warning: burnt class B tokens do not decrease class A tokens\n     * class A tokens remain in class B contract address\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n        balances[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     * Warning: burnt class B tokens do not decrease class A tokens\n     * class A tokens remain in class B contract address\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balances[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n\n}\n","abiDocs":[{"constant":true,"inputs":[],"name":"name","payable":false,"stateMutability":"view","type":"function","signature":"name()","signatureHash":"06fdde03"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","payable":false,"stateMutability":"nonpayable","type":"function","signature":"transferFrom(address,address,uint256)","signatureHash":"23b872dd"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","payable":false,"stateMutability":"view","type":"function","signature":"balanceOf(address)","signatureHash":"70a08231"},{"constant":true,"inputs":[],"name":"symbol","payable":false,"stateMutability":"view","type":"function","signature":"symbol()","signatureHash":"95d89b41"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","payable":false,"stateMutability":"nonpayable","type":"function","signature":"transfer(address,uint256)","signatureHash":"a9059cbb"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event","signature":"Transfer(address,address,uint256)","signatureHash":"ddf252ad"}]}
